*written by PeterAlbus，Copyright © 2021 - SHOU 1951123 Hong Wu*

---

# 附录 常见缩写及解释

+ ALU 算术逻辑单元
+ CU 控制单元
+ ACC 运算器的累加器
+ MAR 存储器地址寄存器
+ MDR 存储器数据寄存器
+ MQ 运算器的乘商寄存器
+ X 操作数寄存器
+ PC 程序计数器
+ IR 指令寄存器
+ MIPS 百万条指令每秒
+ CPI 执行一条指令所需的时钟周期
+ FLOPS 浮点运算每秒
+ MBPS 兆字节每秒
+ DMA 直接存储器存取
+ BS 总线忙
+ BR 总线请求
+ BG 总线同意
+ MROM 掩模型只读存储器
+ PROM 可编程只读存储器
+ EPROM 可擦除可编程只读存储器
+ EEPROM 用电可擦除可编程只读存储器
+ MCT 存取周期
+ CS(上划线)片选信号（低电平有效）
+ WE(上划线)写允许信号（低电平为写，高电平为读）
+ V CC 代表电源
+ GND 代表接地端
+ RAS(上划线) 行地址选通
+ CAS(上划线) 列地址选通
+ CCW 通道指令
+ DBR 数据缓冲寄存器
+ INTR 中断请求触发器
+ MASK 屏蔽触发器
+ AR 主存地址寄存器
+ WC 字计数器
+ BR 数据缓冲寄存器
+ DAR 设备地址寄存器
+ DREQ 向DMA接口提出申请
+ HRQ 发出总线使用权的请求信号
+ RISC 精简指令系统计算机
+ CISC 复杂指令系统计算机
+ NOP 空操作
+ HLP 停机
+ RET 子程序返回
+ IRET 中断返回
+ SP 堆栈指针
+ FLASH MEMORY 闪速存储器

# 第一章 计算机系统概论

### 1.1 计算机系统简介

#### 1.1.1 计算机的软硬件概念

计算机系统由“硬件”和“软件”两大部分组成。

> **硬件**是指计算机的实体部分，它由看得见摸得着的各类电子元器件，各类光、电、机设备的事物组成，如主机、外部设备等。

> 所谓**软件**，它看不见摸不着，由人们实现编制的具有各类特殊功能的程序组成。

计算机的软件又可以分为两大类：系统软件和应用软件。

#### 1.1.2 计算机的层次结构

![五级层次结构](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_01.png)

### 1.2 计算机的基本组成

#### 1.2.1 冯诺依曼计算机的特点

+ 由运算器、存储器、控制器、输入设备和输出设备五大部件组成
+ 指令和数据以同等地位存放于存储器内
+ 指令和数据均用二进制表示
+ 指令由操作码和地址码组成，操作码表示操作性质，地址码表示操作数位置
+ 指令在存储器内按顺序存放，通常按顺序执行，特定条件下也可改变执行顺序
+ 机器以**运算器**为中心

#### 1.2.2 现代计算机硬件框图

+ 以**存储器**为中心

![存储器为中心](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_03.png)

+ 运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内
+ 存储器用来存放数据和程序
+ 控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果
+ 输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式
+ 输出设备可将机器运算结果转换为人们熟悉的信息形式

![现代计算机硬件框图](https://www.peteralbus.com:8440/pictrue/private/co_02.png)

### 1.3 计算机硬件的主要技术指标

+ 机器字长
+ 存储容量
+ 运算速度

---

# 第二章 计算机的发展及应用

### 2.1 计算机的发展史

#### 2.1.1 计算机的产生和发展

+ 第一台电子计算机：1946 美国 ENIAC

+ 现代计算机产生的驱动力：需求+技术发展

+ 硬件技术的发展：

  电子管(第一代计算机)→晶体管(第二代计算机)→中小规模集成电路(第三代计算机,几十/上百个元件)→大规模集成电路(上千个元件)→超大规模集成电路(一片IC芯片上能容纳数万个以上元件)

  计算机的更新换代以**电子器件**为依据

#### 2.1.2 微型计算机的出现和发展

微处理器芯片 1971年(4位、8位、...、64位)

存储器芯片 1970年

Moore定律：微芯片上集成的晶体管数目每三年翻两番

#### 2.1.3 软件计数的兴起和发展

##### 1.各种语言

机器语言-面向机器

汇编语言-面向机器

高级语言-面向问题

+ FORTRAN 科学计算
+ PASCAL 结构化程序设计
+ C++ 面向对象
+ Java 适应网络环境

##### 2.系统软件

+ **语言处理程序**：汇编程序，编译程序，解释程序
+ **操作系统**：DOS UNIX Windows
+ **服务型程序**：装配 调试 诊断 排错
+ **数据库管理系统**：DB和DBMS
+ **网络软件**

##### 3.软件发展的特点

+ 开发周期长
+ 制作成本昂贵
+ 检测软件产品质量的特殊性

### 2.2 计算机的应用

+ 科学计算和数据处理
+ 工业控制和实时控制
+ 网络技术
  + 电子商务
  + 网络教育
+ 虚拟现实
+ 办公自动化和管理信息系统
+ CAD(Computer Aided Desgine)/CAM(Computer Aided Manufacturing)/CIMS(Computer Intergrated Manufacturing System)
+ 多媒体技术
+ 人工智能

### 2.3 计算机的展望

替代传统的硅芯片：光计算机、DNA生物计算机、量子计算机

---

# 第三章 系统总线

### 3.1 总线的基本概念

> **总线**(bus)是连接多个部件的信息传输线，是各部件共享的信息传输介质。

使用总线的原因：I/O设备不断增多，人们希望随时增添或减撤设备**。**

**总线结构的举例**：

+ 单总线结构框图

  ![单总线](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_04.png)

+ 存储器为中心的双总线

  ![双总线](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_05.png)

### 3.2 总线的分类

+ 片内总线：芯片内部的总线

+ 系统总线：计算机各部位之间的信息传输线

  + 数据总线：双向，与机器字长，存储字长有关
  + 地址总线：单向，与存储地址，I/O地址有关
  + 控制总线：有出(存储器读写、总线允许、中断确认)、有入(中断请求、总线请求)

+ 通信总线：用于计算机系统之间或计算机系统与其他系统之间的通信

  传输方式：

  + 串行通信总线
  + 并行通信总线

### 3.3 总线特性及性能指标

#### 3.3.1 总线特性

总线的物理实现：印制在电路板上

![总线物理实现](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_06.png)

+ 机械特性：尺寸、形状、管脚数及排列顺序
+ 电气特性：传输方向和有效的电平范围
+ 功能特性：每根传输线的功能(地址、数据、控制)
+ 时间特性：任意一根线在什么时间内有效

#### 3.3.2 总线的性能指标

+ **总线宽度**：数据线根数
+ **总线带宽**：每秒传输的最大字节数(MBps)
+ **时钟同步/异步**：同步/不同步
+ **总线复用**：地址线与数据线服用
+ **信号线数**：地址线、数据线和控制线的综合
+ **总线控制方式**：并发、自动、仲裁、逻辑、计数
+ 其他指标：**负载能力**

#### 3.3.3 总线标准

> **总线标准**，可视为系统与各模块，模块与各模块之间的一个互联的标准界面。

采用总线标准可以为计算机接口的软硬件设计提供方便。

流行的总线标准：

+ ISA
+ EISA
+ VESA(LV-BUS)
+ PCI
+ AGP
+ RS-232
+ USB

### 3.4 总线结构

+ 单总线结构：已在-3.1 总线的基本概念-处展示

  这类总线通常被小型或微型计算机使用

+ 多总线结构

  + 双总线结构

    ![总线结构](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_07.png)

  + 三总线结构

    ![总线结构](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_08.png)

  + 三总线结构的又一形式

    ![总线结构](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_09.png)

  + 四总线结构

    ![总线结构](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_10.png)

+ 总线结构举例(P55)

  + 传统卫星总线结构
  + VL-BUS局部总线结构
  + PCI总线结构
  + 多层PCI总线结构

### 3.5 总线控制

#### 3.5.1 总线判优控制

> 总线上的设备分为主设备和从设备。
>
> **主设备**：对总线有控制权。
>
> **从设备**：响应从设备发来的总线命令
> 
> 当多个主设备要使用总线时，就由总线控制器的**判优**、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线。

总线判优控制

+ 集中式
  + 链式查询
    + 离控制部件最近的设备有最高的优先权
    + 对电路故障敏感
    + 使用2根线确定总线控制权
  + 计数器定时查询
    + 计数可以从0开始，也可以从上次结束的地方开始(会导致优先级不同)
    + 电路故障不如链式查询敏感，但增加了设备地址线，控制也较复杂
    + 使用$log_2n$条线确定总线控制权
  + 独立请求方式
    + 响应速度快，优先次序灵活
    + 控制线数量多，控制也更复杂
    + 使用2n根线确定总线控制权
+ 分布式

![总线判优控制](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_11.png)

#### 3.5.2 总线通信控制

+ **目的**：解决通信双方协调配合问题

+ 总线传输周期：

  + 申请分配阶段：主模块申请，总线仲裁
  + 寻址阶段：主模块向从模块给出地址和命令
  + 传数阶段：主模块和从模块交换数据
  + 结束阶段：主模块撤销有关信息

+ 总线通信的四种方式

  + 同步通信：由统一时标控制数据传送
  + 异步通信：允许各模块速度的不一致性
    + 不互锁：从设备没有反馈
    + 半互锁：等待从设备有反馈后主设备才能撤销请求
    + 全互锁：等待从设备有反馈后主设备才能撤销请求，等待主设备撤销请求后才能撤销回答
  + 半同步通信：若检测到WAIT信号，插入时钟(等待)周期(同步、异步结合)
  + 分离式通信：充分挖掘系统总线每个瞬间的潜力
    + 子周期1：主模块申请占用总线，使用后放弃总线使用权
    + 子周期2：从模块申请占用总线传输数据

  前三种通信的共同点：

  + 首先申请总线
  + 主模块通过总线向从模块发送请求
  + 从模块准备数据
  + 从模块传输数据

  在准备数据时总线空闲

  分离式通信：

  各模块有权申请占用总线

  异步通信

  各模块准备数据时都不占用总线

  **充分提高了总线的有效占用**

---

# 第四章 存储器

### 4.1 概述

#### 4.1.1 存储器的分类

##### 1.按存储介质分类

+ **半导体存储器** TTL,MOS (易失)
+ **磁表面存储器** 磁头,载磁体 (非易失)
+ **磁芯存储器** 硬磁材料,环状元件 (非易失)
+ **光盘存储器** 激光,磁光材料 (非易失)

##### 2.按存取方式分类

+ 存取时间与物理地址无关(随机访问)
  + 随机存储器
  + 只读存储器
+ 存取时间与物理地址有关(串行访问)
  + 顺序存储存储器 磁带
  + 直接存取存储器 磁盘

##### 3.按在计算机中的作用分类

+ 主存储器
  + RAM
    + 静态RAM
    + 动态RAM
  + ROM
    + MROM(掩模式只读存储器)
    + PROM(可编程只读存储器)
    + EPROM(可擦编程只读存储器)
    + EEPROM(带电可擦可编程只读存储器)
+ Flash Memory
+ 高速缓冲存储器(Cache)
+ 辅助存储器

#### 4.1.2 存储器的层次结构

##### 1.存储器三个重要特性的关系

![三个重要特性的关系](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_12.png)

##### 2.缓存-主存层次和主存-辅存层次

缓存-主存：速度

主存-辅存：容量

### 4.2 主存储器

#### 4.2.1 概述

##### 1.主存的基本组成

![主存的基本组成](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_13.png)

##### 2.主存和CPU的联系

![主存和CPU的联系](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_14.png)

##### 3.主存中存储单元地址的分配

> 字节：8位二进制数
>
> 字：根据机器字长不同，用n个字节表示一个字

+ 一个字中的高位字节地址表示字地址

  | 字地址 | 字节地址 | 字节地址 | 字节地址 | 字节地址 |
  | :----: | :------: | :------: | :------: | :------: |
  |   0    |    0     |    1     |    2     |    3     |
  |   4    |    4     |    5     |    6     |    7     |
  |   8    |    8     |    9     |    10    |    11    |

+ 一个字中的低位字节地址表示字地址

  | 字地址 | 字节地址 | 字节地址 |
  | :----: | :------: | :------: |
  |   0    |    1     |    0     |
  |   2    |    3     |    2     |
  |   4    |    5     |    4     |

按字寻址，需要拿出n根地址线(2^n=字节数目)，其余位标识字地址，寻址范围为2^(地址线数目-n)

##### 4.主存的技术指标

+ 存储容量
+ 存储速度
  + 存取时间
  + 存取周期：连续两次独立的存储器操作所需的最小间隔时间
+ 存储器的带宽 位/秒

#### 4.2.2 半导体存储芯片简介

##### 1.基本结构

![半导体存储芯片](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_15.png)

```
芯片容量=2^地址线条数*数据线位数
```

片选线CS/CE,读写控制线WE(Write Enable),OE(Output Enable) 上划线代表：低电平有效

##### 2.半导体存储芯片的译码驱动方式

+ 线选法：仅一个地址译码器，选择对应的字线，容量大时不合适

+ 重合法：

  ![重合法](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_16.png)

#### 4.2.3 随机存取存储器(RAM)

##### 1.静态RAM(SRAM)

> 静态RAM使用触发器原理储存信息，在掉电时丢失全部信息。

+ 基本电路

  ![RAM1](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_17.png)

+ 读操作

  ![RAM2](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_18.png)

+ 写操作

  ![RAM3](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_19.png)

+ 静态RAM读、写时序

  ![RAM4](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_20.png)

  ![RAM5](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_21.png)

##### 2.动态RAM(DRAM)

> 动态RAM靠电容存储电荷的原理储存信息，电容上有足够电荷表示1，无足够电荷则表示0。电荷不能长久维持，因此必须在2ms内对所有存储单元恢复一次原状态，这个过程称为再生或刷新。

基本单元电路：

![RAM6](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_22.png)

读出信息与原存信息相反

写入信息与输入信息相同

+ 动态RAM刷新

  刷新与行地址有关

  + 集中刷新：每隔一段时间刷新全部
  + 分散刷新：一个存取周期包含读写+刷新
  + 异步刷新：每隔一段时间刷新一行，可将刷新安排在指令译码阶段

##### 3.动态RAM和静态RAM的比较

目前，动态RAM的应用比静态RAM广得多。

|          | DRAM   | SRAM   |
| -------- | ------ | ------ |
| 存储原理 | 电容   | 触发器 |
| 刷新     | 有     | **无** |
| 集成度   | **高** | 低     |
| 芯片引脚 | **少** | 多     |
| 功耗     | **小** | 大     |
| 价格     | **低** | 高     |
| 速度     | 慢     | **快** |

#### 4.2.4 只读存储器(ROM)

##### 1.掩模ROM(MROM)

行列选择线交叉处有MOS管为1，否则为0

##### 2.PROM(一次性编程)

通过熔丝，熔丝断为0，未断为1

##### 3.EPROM(多次性编程)

N型沟道浮动栅MOS电路：写入：电压，擦除：紫外线

##### 4.EEPROM(多次性编程)

+ 电可擦写
+ 局部擦写
+ 全部擦写

##### 5.Flash Memory(闪速型存储器)

比EEPROM快，具备RAM功能

#### 4.2.5 存储器与CPU的连接

##### 1.存储器容量的扩展

+ 位扩展(增加存储字长)

  用2片1K\*4位的存储芯片组成1K\*8位的存储器

+ 字扩展

  用2片1K\*8位的存储芯片组成2K\*8位的存储器

+ 字、位扩展

  上面两者结合而成

##### 2.存储器与CPU的连接

+ 地址线的连接
+ 数据线的连接
+ 读/写命令线的连接
+ 片选线的连接
+ 合理选择存储芯片
+ 其他：时序、负载

参考书P94 例4.1/4.2

#### 4.2.6 存储器的校验

##### 1.编码的最小距离

> 编码的最小距离，是指在一种编码系统中，任意两组合法代码之间二进制位数的最少差异。

例如，假如一个编码系统，合法编码有1111,1100,0000,则最小编码距离为2。

编码的纠错、检错能力与编码的最小距离有关。

设L为编码的最小距离，D为检测错误的位数，C为纠正错误的位数，则：

```c
L-1=D+C(D>=C)
```

##### 2.汉明码

> “汉明码”是一种“错误纠正码”，可以用来检测并且纠正数据从发送端发往接收端中发生的错误

汉明码是具有一位纠错能力的编码。

若原值有n位，汉明码的组成需要添加k位检测位
$$
2^k \geq n+k+1
$$
检测位的位置为2^i(i=0,1,2,3...)

添加检测位后分组，每个检测位对应第(i+1)组：

+ 对于检测位2^i，将所有数的位置转换为2进制
+ 如有7位数字，则分别为001位、010位、011位....
+ 将所有第i+1位为1的数字分到该组，如检测为为2^0=1，则001,011,101,111(第1，3，5，7个数)属于该组

分组后进行校验，分为奇校验与偶校验

对每组进行检测，要求每组的数字之和为奇数/偶数(对于二进制来说，即拥有奇数/偶数个1)(可通过对所有数进行异或运算，若结果为0则为偶数，结果为1则为奇数)

若检测出错，通过找到多个出错的组的公共位即可找到出错的位置

#### 4.2.7 提高访存速度的措施

+ 采用高速器件
+ 采用层次结构Cache-主存
+ 调整主存结构
  + 单体多字系统
  + 多体并行系统
    + 高位交叉 各个体并行工作
    + 低位交叉 在不改变存储器周期的前提下，增加存储器带宽
    + 存储器控制部件
  + 高性能存储芯片
    + SDRAM CPU无需等待，在系统时钟的控制下进行读出和写入
    + RDRAM 主要解决了存储器带宽问题
    + 带Cache的DRAM

### 4.3 高速缓冲器

#### 4.3.1 概述

##### 1.问题的提出

避免CPU“空等”的现象

解决CPU和DRAM的速度差异

![CACHE](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_23.png)

##### 2.Cache的工作原理

+ 主存和缓存按块存储，块的到校相同

+ 命中与未命中

  + 命中：主存块调入缓存，主存块与缓存建立了对应关系
  + 用 标记记录 与某缓存块建立了对应关系的 主存块号
  + 未命中：未建立对应关系

+ 命中率

  + CPU欲访问的信息在Cache中的比率
  + 命中率 与 Cache 的 **容量** 与 **块长** 有关 

+ Cache-主存系统的效率
  $$
  e=\frac{访问Cache的时间}{平均访问时间}
  $$

##### 3.Cache的基本结构

  ![Cache结构](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_24.png)

##### 4.Cache的读写操作

+ 读：

  ![CACHE读](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_25.png)

+ 写：保证CACHE和主存的一致性

  + 写直达法

    写操作时既写入Cache又写入主存

    写操作时间就是访问主存的时间，更新策略容易时间

  + 写回法

    只写入Cache，写操作时间就是访问Cache的时间

    Cache被替换的块需要写回主存，增加了Cache 的复杂性

##### 5.Cache的改进

+ 增加Cache级数
+ 统一缓存和分立缓存

#### 4.3.2 Cache-主存地址的映射

##### 1.直接映射

每个缓存块对应多个主存块

缓存标记储存的主存块，比较器检测是否命中

##### 2.全相联映射

主存中的任意一块可以映射到缓存中的任意一块

##### 3.组相联映射

某一主存块可以映射到缓存的某一组的任意一块(直接映射和全相联映射结合)

#### 4.3.3 替换算法

+ FIFO
+ LRU

### 4.4 辅助存储器

+ 特点：不直接与CPU交换信息
+ 硬磁盘
+ 软盘
+ 光盘

---

# 第五章 输入输出系统

### 5.1 概述

#### 5.1.1 输入输出系统的发展概况

+ 早期：分散连接，CPU和I/O设备串行工作，程序查询方式
+ 接口模块和DMA阶段
  + 总线连接
  + CPU和I/O设备并行工作
    + 中断方式
    + DMA方式
+ 具有通道结构的阶段
+ 具有I/O处理机的阶段

#### 5.1.2 输入输出系统的组成

+ I/O软件
  + I/O指令 CPU指令的一部分
  + 通道指令 通道自身的指令
+ I/O硬件
  + 设备-I/O接口
  + 设备-设备控制器-通道

#### 5.1.3 I/O设备与主机的联系方式

+ I/O设备编址方式

  + 统一编址 用取数、存数指令
  + 不统一编址 有专门的I/O指令

+ 设备选址

  用设备选择电路识别是否被选中

+ 传送方式

  + 串行
  + 并行

+ 联络方式

  + 立即响应
  + 异步工作采用应答信号
  + 同步工作采用同步时标

+ 连接方式

  + 辐射式连接

    每个设备都配有一套控制线路和一组信号线

    不便于增删设备

  + 总线连接

    便于增删设备

#### 5.1.3 I/O设备与主机信息传送的控制方式

+ 程序查询方式：CPU和I/O串行工作，踏步等待
+ 程序中断方式：CPU和I/O设备并行工作
  + I/O准备：CPU完成自身任务
  + 与主机交换信息：CPU暂停先行程序
+ DMA方式：CPU和I/O设备并行工作
  + 主存和I/O之间有一条直接数据通道
  + 不中断现有程序
  + 周期挪用

![三种方式的比较](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_26.png)

### 5.2 I/O设备

#### 5.2.1 概述

> 中央处理器和主存构成了主机，除主机外的大部分硬件设备都可称为I/O设备或外部设备，或外围设备，简称外设。

外部设备大致分为3类：

+ **人机交互设备：**键盘、鼠标、打印机、显示器
+ **计算机信息存储设备：**磁盘、光盘、磁带
+ **机-机通信设备：**调制解调器等

#### 5.2.2 输入设备

+ 键盘
  + 按键
  + 判断哪个键被按下
  + 将此键翻译成ASCII码
+ 鼠标
  + 机械式 金属球，电位器
  + 光电式 光电转换器
+ 触摸屏

#### 5.2.3 输出设备

+ 显示器
  + 字符显示 字符发生器
  + 图形显示 主观图像
  + 图像显示 客观图像
+ 打印机
  + 击打式 点阵式
  + 非击打式 激光、喷墨

#### 5.2.4 其他I/O设备

+ A/D,D/A转换器(数字/模拟信号转换器)
+ 终端-由键盘和显示器组成
+ 汉字处理

#### 5.2.5 多媒体技术

> 多媒体（Multimedia）是多种[媒体]()的[综合]()，一般包括文本，声音和图像等多种媒体形式。
>
> 在计算机系统中，多媒体指组合两种或两种以上媒体的一种人机交互式[信息交流]()和[传播媒体]()。使用的媒体包括文字、图片、照片、声音、动画和影片，以及程式所提供的互动功能。

+ 多媒体计算机的关键技术
  + 视频和音频数据的压缩与解压缩技术
  + 多媒体专用芯片
  + 大容量存储器
  + 适用于多媒体技术的软件

### 5.3 I/O接口

#### 5.3.1 概述

为什么要放置接口？

+ 实现设备的选择
+ 实现数据缓冲达到速度匹配
+ 实现数据串——并格式转换
+ 实现电平转换
+ 传送控制命令
+ 反映设备的状态

#### 5.3.2 接口的功能和组成

##### 1. 总线连接方式的I/O接口电路

+ 设备选择线
+ 数据线
+ 命令线
+ 状态线

![I/O接口电路](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_27.png)

##### 2.接口的功能和组成

|     功能     |       组成        |
| :----------: | :---------------: |
|     选址     |   设备选择电路    |
|   传送命令   | 命令寄存器/译码器 |
|   传送数据   |  数据缓冲寄存器   |
| 反映设备状态 |   设备状态标记    |

+ 完成触发器D
+ 工作触发器B
+ 中断请求触发器INTR
+ 屏蔽触发器MASK

#### 5.3.3 接口类型

+ 按数据传送方式分类
  + 并行接口
  + 串行接口
+ 按选择的灵活性
  + 可编程接口
  + 不可编程接口
+ 通用性
  + 通用接口
  + 专用接口
+ 控制方式(程序查询方式没有接口)
  + 中断接口
  + DMA接口

### 5.4 程序查询方式

#### 5.4.1 程序查询流程

单个和多个设备的程序查询流程：

![程序查询流程](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_28.png)

#### 5.4.2 程序流程

![程序流程](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_29.png)

#### 5.4.3 接口电路

![接口电路](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_30.png)

### 5.5 程序中断方式

#### 5.4.1 中断的概念

> **中断**是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。

#### 5.4.2 中断的产生

CPU启动I/O设备后，继续执行主设备，I/O设备在数据准备完成后发起中断，CPU处理I/O。

CPU与I/O设备并行工作

#### 5.4.3 程序中断方式接口电路

##### 1. 配置中断请求触发器(INTR)和中断屏蔽触发器(MASK)

INTR=1 CPU发起中断请求

MASK=1 中断被屏蔽

D: 完成触发器，代表I/O准备完成

##### 2.排队器

+ 硬件：在CPU内或接口电路中

+ 软件

##### 3.中断向量地址形成部件

+ 由软件产生
+ 硬件向量法：硬件产生向量地址，再由向量地址找到入口地址

##### 4.程序中断方式接口电路的基本组成

![三种方式的比较](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_31.png)

#### 5.4.4 I/O中断处理过程

+ CPU响应中断的条件和时间

  + 条件：EINT允许中断触发器=1

  + 时间：D=1且MASK=0

    在每条指令执行阶段的结束前CPU发送中断查询信号(INTR置1)

#### 5.4.5 中断服务程序的流程

##### 1.流程

+ 保护现场
  + 程序断点的保护
  + 寄存器内容的保护
+ 中断服务
+ 恢复现场
+ 中断返回

##### 2.单重中断和多重中断

单重中断：不允许中断现行的中断服务程序

多重中断：允许级别更高的中断源中断现行的中断服务车光绪

### 5.6 DMA方式

#### 5.6.1 DMA方式的特点

+ DMA通过DMA接口与主存直接交换数据，而不需要经过CPU
+ DMA与主存交换数据的三种方式
  + 停止CPU访问主存：控制简单、CPU处于不工作状态、未充分发挥CPU对主存的利用率
  + 周期挪用：DMA请求时CPU没有访存则成功，DMA与CPU同时请求访存时优先DMA，否则等待CPU
  + DMA与CPU交替访问：工作周期中专为DMA分出时间，不需要建立申请和归还总线的使用权

#### 5.6.2 DMA接口的功能和组成

##### 1.DMA接口功能

+ 向CPU申请DMA传送
+ 处理总线控制权的转交
+ 管理系统总线、控制数据传送
+ 确定数据传送的首地址和长度
+ DMA传送结束时，给出完成信号

##### 2.DMA接口组成

![DMA](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_32.png)

#### 5.6.3 DMA的工作过程

##### 1.DMA传送过程

+ 预处理
+ 数据传送
+ 后处理
  + 校验数据正确性
  + 是否继续使用DMA
  + **由中断服务程序完成**

##### 2.DMA接口与系统的连接方式

+ 具有公共请求线的DMA请求
+ 独立的DMA请求

##### 3.DMA方式与程序中断方式的比较

|              | 中断方式     | DMA方式      |
| ------------ | ------------ | ------------ |
| 数据传送     | 程序         | 硬件         |
| 响应时间     | 指令执行结束 | 存取周期结束 |
| 处理异常情况 | 能           | 不能         |
| 中断请求     | 传送数据     | 后处理       |
| 优先级       | 低           | 高           |

#### 5.6.4 DMA接口的类型

+ 选择型：物理上连接多个设备，逻辑上只连接一个
+ 多路型：物理上连接多个，逻辑上也允许多个同时工作
  + 原理：并发

---

# 第六章 计算机的运算方法

### 6.1 无符号数和有符号数

#### 6.1.1 无符号数

寄存器的位数反映无符号数二点表示范围

8位：0~255

16位：0~65535

#### 6.1.2 有符号数

##### 1.机器数与真值

|  真值   |          机器数          |
| :-----: | :----------------------: |
| +0.1011 | 0,1011[小数点在符号位后] |
|  -1100  |   1,1100[小数点在末尾]   |

##### 2.原码表示法

整数：
$$
\begin{equation}[x]_原= 
\begin{cases}
0,x& 2^n>x \geq 0 \\
2^n-x& 0\geq x >-2^n
\end{cases}
\end{equation}
$$
小数：
$$
\begin{equation}[x]_原= 
\begin{cases}
x& 1>x \geq 0 \\
1-x& 0\geq x >-1
\end{cases}
\end{equation}
$$
即正数符号位为0，负数符号位为1，用逗号将符号位和数值部分隔开

原码的特点：简单、直观

但用原码对负数作加法时会出现问题

解决方法：找一个与负数等价的正数来代替这个负数

##### 3.补码表示法

+ 一个负数加上 “模” 即得该负数的补数
+ 一个正数和一个负数互为补数时，它们绝对值之和即为 模 数
+ 正数的补数即为其本身

整数（n为整数位数）：
$$
\begin{equation}[x]_补= 
\begin{cases}
0,x& 2^n>x \geq 0 \\
2^{n+1}+x& 0\geq x >-2^n
\end{cases}
\end{equation}
$$
小数：
$$
\begin{equation}[x]_补= 
\begin{cases}
x& 1>x \geq 0 \\
2+x& 0\geq x >-1
\end{cases}
\end{equation}
$$
**求补码的快捷方式**：真值为负时，补码=原码除符号位外每位取反，末尾+1

##### 4.反码表示法

负数的原码：符号位外每一位都取反

##### 5.三种机器数的总结

+ 最高位为符号位
+ 对于整数，原码=补码=反码
+ 对于负数，符号位为1，其数值部分：
  + 原码取反+1→补码
  + 原码取反→反码

##### 6.移码表示法

补码难以判断其真值大小：补码的符号位取反
$$
[x]_移=2^n+x (x^n>x \geq -2^n)
$$
最小真值的移码为全0

### 6.2 数的定点表示和浮点表示

#### 6.2.1 定点表示

小数点按约定方式标出

#### 6.2.2 浮点表示

浮点数的一般形式：
$$
N=S \times r^j
$$
S：尾数，j阶码，r基数(数值)

计算机中r取2的n次方

当r=2时：
$$
N=11.0101=0.110101 \times 2^{10}
$$
——规格化数

计算机中：S存小数，可正可负，j存整数，可正可负

+ 浮点数的表示形式

  由j阶码和S尾数共同表示

  阶码包括阶符和阶码的数值部分，尾数同理，包含数符和尾数的数值部分

  阶码的位数反映浮点数的表示范围

  尾数的尾数反映浮点数的精度

+ 浮点数的表示范围

  + 上溢：阶码>最大阶码
  + 下溢：阶码<最小阶码 按照**机器零**处理

+ 浮点数的规格化形式

  + r=2 尾数最高位为1
  + r=4 尾数最高2位不全为0
  + r=8 尾数最高3位不全为0

  r越大，浮点数表示范围越大，浮点数精度降低

+ 机器零：
  + 阶码用移码，尾数用补码表示时，机器零才为：0,0000;0,00000

### 6.3 定点运算

#### 6.3.1 移位运算

+ 移位的意义：与加减和配合实现乘除运算

左移：绝对值扩大

右移：绝对值缩小

+ 算数移位规则

  符号位不变

  正数移位：填补代码0

  负数移位：

  + 原码：添补0
  + 反码：添补1
  + 补码：右移添0，左移添1、

+ 算数移位和逻辑移位的区别：算术移位考虑符号位、补反码，逻辑移位不考虑

#### 6.3.2 加减法运算

##### 1.补码加减运算

连同符号位一起加，符号位产生的进位自然丢掉

##### 2.溢出判断

+ 一位符号位判断溢出：参加运算的两个数符号位相同，其结果的符号与原操作数不同，即为溢出
+ 两位符号位判断溢出：结果符号位不同即为溢出

#### 6.3.3 乘法运算

##### 1.分析笔算乘法

+ 符号位单独处理
+ 乘数的某一位决定是否加被乘数
+ 4个位积一起相加——难以实现
+ 乘积的尾数扩大一倍

##### 2.改进

+ 每一位乘法运算转化为加法运算后，右移一位

总结：乘法运算可以用加法和移位实现

##### 3.原码乘法

乘积的符号位单独处理

数值部分为绝对值相乘

+ 原码一位乘
+ 原码两位乘

##### 4.补码乘法

+ 被乘数任意，乘数为正

  同原码乘，但加和移位按补码规则运算，乘积的符号自然形成

+ 被乘数任意，乘数为负

  乘数[y]补去掉符号位，其余同上

  最后加上[-x]补校正

+ Booth算法：初始时在乘数右边增加一个辅助位，根据当前位和辅助位两位判断：

  + 00/11，不加，移位
  + 01，+[x]补，移位
  + 10，+[-x]补，移位

#### 6.3.4 除法运算

+ 符号位异或形成
+ `abs(x)-abs(y)>0`上商1，反之上商0
+ 余数左移一位，低位补0，减除数
+ 1倍字长加法器
+ 在寄存器最末尾上商

恢复余数法/加减交替法

### 6.4 浮点四则运算

#### 6.4.1 浮点加减运算

对阶：求阶差，使小数点位置看齐(阶数小的向阶数大的看齐)

尾数求和

+ 规格化数的判断：
  + 原码：第一数位为1
  + 补码：符号位和第一数位不同

舍入：

对阶右规的过程中尾数末尾可能丢失，需要考虑舍入

+ 0舍置1法
+ 恒置1法

---

# 第七章 机器指令

### 7.1 机器指令

#### 7.1.1 指令的一般格式

\[操作码字段\]\[地址码字段\]

##### 1.操作码 反映机器做什么操作

+ 长度固定
+ 长度可变
+ 扩展操作码技术：操作码的位数随着地址数的减少而增加
  + 4位、8位操作码分别对应15条n地址、n-1地址指令

##### 2.地址码

+ 四地址

  + 第一操作数地址
  + 第二操作数地址
  + 结果地址
  + 下一条指令地址

  4次访存

+ 三地址

  + 使用PC代替下一条指令地址
  + 第一第二操作数地址及结果地址

  4次访存

+ 二地址

  + 使用某一操作数地址代替结果地址，结果存于操作数
  + 结果存于ACC则仅需3次访存

  4次访存

+ 一地址

  + 使用ACC代替某一操作数

  2次访存

+ 零地址

  + 无地址码

#### 7.1.2 指令字长

指令字长决定于

+ 操作码的长度
+ 操作数地址的长度
+ 操作数地址的个数

指令字长固定：指令字长=存储字长

指令字长可变：按字节的倍数变化

### 7.2 操作数类型和操作种类

#### 7.2.1 操作数类型	

+ 地址 无符号整数
+ 数字 定点数、浮点数、十进制数
+ 字符 ASCII
+ 逻辑数 逻辑运算

#### 7.2.2 数据在存储值中的存放方式

+ 字地址为低字节地址
+ 字地址为高字节地址

#### 7.2.3 操作类型

##### 1.数据传送

从寄存器/存储器到存储器/寄存器

例如：MOVE/STORE/LOAD/PUSH/POP

##### 2.算数逻辑操作

加减乘除与非...

例：ADD SUB MUL DIV INC DEC CMP AND OR NOT XOR

##### 3.移位操作

算术移位，逻辑移位，循环移位

##### 4.转移

无条件转移：JMP

条件转移：JZ,JO,JC,SKP

调用和返回(CALL,RETURN)

陷阱与陷阱指令：意外事故的中断，一般由CPU自动产生并执行(隐指令)

##### 5.输入输出

### 7.3 寻址方式

> **寻址**：确定本条指令的操作数地址，下一条欲执行指令的指令地址

寻址方式：指令寻址、数据寻址

#### 7.3.1 指令寻址

顺序：PC+1→PC

跳跃：由转移指令给出

#### 7.3.2 数据寻址

| 操作码 | 寻址特征 | 形式地址A |
| ------ | -------- | --------- |

> 形式地址：指令字中的地址
>
> 有效地址：操作数的真实地址

约定指令字长=存储字长=机器字长

##### 1.立即寻址

形式地址就是操作数

##### 2.直接寻址

有效地址由形式地址直接给出，访问一次存储器

##### 3.隐含寻址

操作数地址隐含在操作码中，如ADD的一个操作数隐含在ACC中

##### 4.间接寻址

`EA=*A`，有效地址由形式地址间接提供，访存2次(一次间址)或多次(多次间址)

可以扩大寻址范围，便于编制程序

##### 5.寄存器寻址

有效地址即为寄存器编号

##### 6.寄存器间接寻址

有效地址在寄存器中，便于编制循环程序

##### 7.基址寻址

EA=(BR)+A,BR为基址寄存器

也可采用通用寄存器作为基址寄存器，寄存器需要用户指定

BR不变，A可变

##### 8.变址寻址

EA=(IX)+A

执行过程中A不变，IX可变

便于处理数组问题

##### 9.相对寻址

EA=(PC)+A

A是相对于当前指令的位移量

广泛用于转移指令

##### 10.堆栈寻址

栈顶地址由SP指出

### 7.4 指令格式举例

#### 7.4.1 设计指令格式时应考虑的各种因素

+ 指令系统的兼容性(向上兼容)
+ 其他因素
  + **操作类型** 包括指令个数以及操作的难易程度
  + **数据类型** 确定哪些数据类型可参与操作
  + **指令格式** 指令字长是否固定
  + **寻址方式** 指令寻址
  + **寄存器个数** 寄存器多少影响指令执行时间

#### 7.4.2 指令格式举例

+ PDP-8 指令字长固定为12位
+ PDD-11 指令字长有16位、32位、48位3种
+ IBM 360
+ INTEL 8086

### 7.4 RISC技术

#### 7.4.1 RISC的产生和发展

RISC(Reduced Instuction Set Computer)

CISC(Complex Instruction Set Computer)

80-20规律：80%的语句仅仅使用20%的计算机指令

能否使用这20%组合成不常用的剩余指令

#### 7.4.2 RISC的主要特征

+ 选用一些简单指令
+ 长度固定、寻址方式少、指令格式种类少
+ 只有LOAD/STORE访存
+ CPU中有多个通用寄存器
+ 采用流水技术，一个时钟周期内完成一条指令
+ 采用组合逻辑实现控制器
+ 采用优化的编译程序

#### 7.4.3 CISC的主要特征

+ 复杂庞大
+ 长度不固定，格式种类多
+ 访存指令不受限制
+ CPU中有专用寄存器
+ 大多数指令需要多个时钟周期执行完毕
+ 采用微程序控制器
+ 难以用优化编译生成高效代码

#### 7.4.4 RISC和CISC的比较

+ RISC更能充分利用VLSI芯片的面积
+ RISC更能提高计算机速度，便于实现指令流水
+ RISC便于设计，降低成本提高可靠性
+ RISC有利于编译程序优化
+ RISC**不易**实现指令程序兼容

---

# 第八章 CPU的结构和功能

### 8.1 CPU的结构

#### 8.1.1 CPU的功能

+ 控制器
  + 取指令
  + 分析指令
  + 执行指令，发出操作命令
  + 控制程序输入以及结构的输出
  + 总线管理
  + 处理异常情况和特殊请求
+ 运算器
  + 实现算数运算和逻辑运算

#### 8.1.2 CPU结构框图

指令控制 PC,IR

操作控制、时间控制 CU,时序电路

数据加工 ALU,寄存器

处理中断 中断系统

![CPU结构框图](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_33.png)

#### 8.1.3 CPU的寄存器

+ 用户可见寄存器

  + 通用寄存器
  + 数据寄存器
  + 地址寄存器
  + 条件码寄存器

+ 控制和状态寄存器

  + 控制寄存器

    PC MAR M MDR IR

    控制CPU操作,其中MAR,MDR,IR用户不可见,PC用户可见

  + 状态寄存器

#### 8.1.4 控制单元CU和中断系统

+ CU 产生全部指令的微操作命令序列
  + 组合逻辑设计
  + 微程序设计
+ 中断系统

#### 8.1.5 ALU

参见第六章

### 8.2 指令周期

#### 8.2.1 指令周期的基本概念

> **指令周期**：取出并执行一条指令所需的全部时间

完成一条指令：

+ 取指、分析：取指周期
+ 执行：执行周期

每条指令的指令周期不同

指令周期还可以加入：间址周期(间接寻址)、终端周期

+ CPU工作周期的标志

  四种性质：

  + 取指令 取指周期
  + 取地址 间址周期
  + 取操作数 执行周期
  + 存程序断点 中断周期

#### 8.2.2 指令周期的数据流

+ 取指周期

  ![](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_34.png)

+ 间址周期

  ![](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_35.png)

+  执行周期——不同指令数据流不同

+ 中断周期

  ![](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_36.png)

### 8.3 指令流水

#### 8.3.1 如何提高机器速度

+ 提高访存速度

  高速芯片 Cache 多体并行

+ 提高I/O和主机之间的传送速度

  中断-DMA-通道-I/O处理机-多总线

+ 提高运算器速度

+ 提高整机处理能力

  + 高速器件
  + 改进系统结构，开发系统的并行性

#### 8.3.2 系统的并行性

+ 并行的概念

  > **并发**：两个或两个以上的事件在同一时间段发生
  >
  > **同时**：两个或两个以上的事件同一时刻发生

+ 并行性的等级

  + 过程级 粗粒度 软件实现
  + 指令级 细粒度 硬件实现

#### 8.3.3 指令流水原理

##### 1.指令的串行执行

取指令1-执行指令1-取指令2-...

总有一个部件空闲

##### 2.指令的二级流水

| 取指令1 | 执行指令1 |           |           |
| ------- | --------- | --------- | --------- |
|         | 取指令2   | 执行指令2 |           |
|         |           | 取指令3   | 执行指令3 |

取指和执行上时间重叠，指令周期减半

##### 3.影响指令流水效率加倍的因素

+ 指令时间>取指事件
+ 条件转移指令对流水有影响：必须等待上条指令执行完成才能确定下一条指令

##### 4.指令的六级流水

![db_01.png (1806×755)](https://file.peteralbus.com/assets/blog/imgs/blogimg/private/co_37.png)

#### 8.3.4 影响指令流水线性能的因素

+ 结构相关：不同指令争用同一功能产生资源冲突

  解决方法

  + 停顿
  + 数据存储器和指令存储器分开
  + 指令预取技术

+ 数据相关：不同指令重叠操作，可能改变操作数的读写访问顺序

  解决方法

  + 后推法
  + 采用旁路技术

+ 控制相关：由转移指令引起

#### 8.3.5 流水线性能

+ 吞吐率：单位时间内流水线完成指令或输出结果的数量

  最大吞吐率：1/每段流水线时间

  实际吞吐率(连续处理n条指令)：n/(流水线段数\*流水线时间+(n-1)\*流水线时间)

+ 加速比：流水线的速度与等功能的非流水线速度之比

  设m段流水线上完成n条指令：nm/(m+n-1)

+ 效率：流水线中各功能段的利用率
  由于流水线有 建立时间 和 排空时间
  因此各功能段的 设备不可能 一直 处于 工作 状态 
  
  效率=流水线各段处于工作时间的时空区/流水线总的时空区=mnt/m(m+n-1)t

#### 8.3.6 流水线的多发技术

+ 超标量技术：并发多条独立指令
+ 超流水线技术：一个时钟周期内再分段
+ 超长指令字技术：编译程序挖掘潜在并行性，多条指令并行

#### 8.3.7 流水线结构

+ 指令流水线结构
  + 完成一条指令分7段：取指令、指令译码、地址形成、取操作数、操作执行、回写结果、修改指令指针
  + 理想情况下7级流水的速度是不使用的7倍
+ 运算流水线
  + 浮点加减运算分为对阶、尾数求和、规格化三段
  + 分段原则：每段操作时间尽量一致

### 8.4 中断系统

#### 8.4.1 概述

+ 引起中断的各种因素
  + 人为设置的中断
  + 程序型事故
  + 硬件故障
  + I/O设备
  + 外部设备(键盘中断)
+ 中断系统需解决的问题
  + 中断源如何向CPU提出请求
  + 同时提出请求如何处理
  + CPU什么条件下,WHEN,HOW,响应中断
  + 如何保护现场
  + 如何寻找入口地址
  + 如何恢复现场，返回
  + 处理中断中如何处理新的中断

#### 8.4.2 中断请求标记和中断判优逻辑

##### 1.中断请求标记INTR

一个请球源一个INTR

多个INTR组成中断请求标记寄存器

+ INTR可以分散在中断源的接口电路中
+ 也可以集中在CPU中断系统内

##### 2.中断判优逻辑

+ 硬件实现：排队器
+ 软件实现：程序查询

#### 8.4.3 中断服务程序入口的寻找

+ 硬件向量法
+ 软件查询法

#### 8.4.4 中断响应

##### 1.中断响应的条件

允许中断触发器EINT=1

##### 2.响应中断的时间

指令执行周期结束时刻CPU发送查询信号

##### 3.中断隐指令

+ 保护程序断点
+ 寻找服务程序入口地址
+ 硬件关中断

#### 8.4.5 保护现场和恢复现场

+ 保护现场
  + 断点：中断隐指令完成
  + 寄存器内容：中断服务程序完成
+ 恢复现场：中断服务程序完成

#### 8.4.6 中断屏蔽技术

> **多重中断**：如果CPU在执行某一中断服务程序过程中,又遇到了新的更高级的中断请求,CPU暂停原中断的处理,而转去处理新的中断,待处理完毕后,再返回继续处理原来的中断,这种中断称为多重中断,也称中断嵌套。

+ 实现多重中断的条件
  + 提前设置开中断指令
  + 优先级别高的中断有权中断优先级别低的中断源

+ 屏蔽技术
  + 屏蔽触发器MASK
  + 屏蔽字
  + 屏蔽技术可改变优先处理等级
  + 可以人为地屏蔽某个中断源地请求，便于程序控制
